{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udfe1 Home Page Flask-Authlib \ud83d\udd10 Welcome \ud83d\udc4b Flask-Authlib - Authentication Library For Flask Web Framework \ud83d\udd25 Installation Create virtual environment for your python project: 1 python -m venv env Virtual Environment The venv module provides support for creating lightweight \u201cvirtual environments\u201d with their own site directories, optionally isolated from system site directories. Python docs - Creation of virtual environments Activate it: Bash/zsh Cmd Powershell Git Bash 1 $ source env/bin/activate 1 C:\\> env\\Scripts\\activate.bat 1 PS C :\\> < venv >\\ Scripts \\ Activate . ps1 Note On Microsoft Windows, it may be required to enable the Activate.ps1 script by setting the execution policy for the user. You can do this by issuing the following PowerShell command: 1 PS C :> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser From python docs 1 $ source env/Scripts/activate Install this library by using pip command: 1 $ pip install -U flask_authlib 1 2 3 4 5 6 7 8 9 10 11 $ pip show flask_authlib Name: Flask-Authlib Version: 1.5.0 Summary: Authentication library for Flask Web Framework Home-page: https://github.com/AbduazizZiyodov/flask-authlib Author: Abduaziz Ziyodov Author-email: abduaziz.ziyodov@mail.ru License: MIT Location: ... Requires: ... If you are a beginner in flask development, you can learn the basics of the flask on the next page \ud83d\ude42 License This project is licensed under the terms of the MIT license.","title":"Home"},{"location":"#home-page","text":"","title":"\ud83c\udfe1 Home Page"},{"location":"#installation","text":"Create virtual environment for your python project: 1 python -m venv env Virtual Environment The venv module provides support for creating lightweight \u201cvirtual environments\u201d with their own site directories, optionally isolated from system site directories. Python docs - Creation of virtual environments Activate it: Bash/zsh Cmd Powershell Git Bash 1 $ source env/bin/activate 1 C:\\> env\\Scripts\\activate.bat 1 PS C :\\> < venv >\\ Scripts \\ Activate . ps1 Note On Microsoft Windows, it may be required to enable the Activate.ps1 script by setting the execution policy for the user. You can do this by issuing the following PowerShell command: 1 PS C :> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser From python docs 1 $ source env/Scripts/activate Install this library by using pip command: 1 $ pip install -U flask_authlib 1 2 3 4 5 6 7 8 9 10 11 $ pip show flask_authlib Name: Flask-Authlib Version: 1.5.0 Summary: Authentication library for Flask Web Framework Home-page: https://github.com/AbduazizZiyodov/flask-authlib Author: Abduaziz Ziyodov Author-email: abduaziz.ziyodov@mail.ru License: MIT Location: ... Requires: ... If you are a beginner in flask development, you can learn the basics of the flask on the next page \ud83d\ude42 License This project is licensed under the terms of the MIT license.","title":"Installation"},{"location":"flask_tutorials/getting_started/","text":"Getting Started Flask is the best micro web framework written in Python \ud83d\udd25 Installation 1 $ pip install -U flask Open your favourite code editor \ud83d\ude0d Create a new *.py file \u2705 Import Flask from the flask framework and define your app: 1 2 3 from flask import Flask app = Flask ( __name__ ) __name__ is the import name for our flask app Create simple view function that returns simple text/html response: 1 2 3 4 5 6 7 8 from flask import Flask app = Flask ( __name__ ) def home_view (): return \"Hello Bro \ud83d\udc4b\" Next, you will should add this view function on your app's url rules. For this, we have to use Flask 's add_url_rule method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from flask import Flask app = Flask ( __name__ ) def home_view (): return \"Hello Bro \ud83d\udc4b\" app . add_url_rule ( rule = \"/\" , view_func = home_view ) flask.Flask.add_url_rule rule should be str view should be function or class For class based views, Flask has as_view method. Routes The method of add_url_rule is used by flask developers very rarely. They use route decorator instead of using add_url_rule and it provides to assign URLs in our app to functions easily. 1 2 3 @app . route ( \"/\" ) def home_view (): return \"Hello Bro \ud83d\udc4b\" \"/\" - url that our view function returns response. route decorator also uses from add_url_rule method : From flask's source code You can return any of the string and binary related types: str , unicode , bytes , bytearray , or if you prefer, you can return an already built response object: 1 2 3 4 5 6 7 from flask import Response app = Flask ( __name__ ) @app . route ( \"/\" ) def function (): return Response ( ... ) View Functions The names we chose for our view functions should be unique. 1 2 3 4 5 6 7 8 9 10 @app . route ( \"/\" ) def home (): return \"Hello!\" @app . route ( \"/home\" ) def home (): return \"Hello from home_2!\" # AssertionError: # View function mapping is overwriting an existing endpoint function: :view_function_name:","title":"Getting Started"},{"location":"flask_tutorials/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"flask_tutorials/http_methods/","text":"HTTP methods We can set specific HTTP methods to our routes. Add methods to the list that you want and give this methods list as route decorator's arguments with methods key ( methods = [ ...] ). For example, you want to allow only the HTTP POST method on your specific route, then you should add POST on methods like this: 1 2 3 @app . route ( \"/\" , methods = [ \"POST\" ]) def home_view (): return \"Hello Bro \ud83d\udc4b\" \u2705 Yeah, we sent a GET request from the browser, but it is not allowed.","title":"HTTP methods"},{"location":"flask_tutorials/http_methods/#http-methods","text":"We can set specific HTTP methods to our routes. Add methods to the list that you want and give this methods list as route decorator's arguments with methods key ( methods = [ ...] ). For example, you want to allow only the HTTP POST method on your specific route, then you should add POST on methods like this: 1 2 3 @app . route ( \"/\" , methods = [ \"POST\" ]) def home_view (): return \"Hello Bro \ud83d\udc4b\" \u2705 Yeah, we sent a GET request from the browser, but it is not allowed.","title":"HTTP methods"},{"location":"flask_tutorials/request_handling/","text":"Handling HTTP Requests There is a flask's Request class that very helps to handle users' requests. You have to import just a request from flask . 1 from flask import request By writing . after request you will see all methods and attributes of the request object in your editor: flask.request request.data Contains the incoming request data as a string in case it came with a mime-type Flask does not handle. request.args - the key/value pairs in the URL query string request.form - the key/value pairs in the body, from a HTML post form, or JavaScript - request that isn't JSON encoded request.files - the files in the body, which Flask keeps separate from form. HTML forms must use enctype=multipart/form-data or files will not be uploaded. request.values - combined args and form, preferring args if keys overlap request.json - parsed JSON data. The request must have the application/json content type, or use request.get_json(force=True) to ignore the content type. All of these are MultiDict instances (except for json). You can access values using: request.form['name'] - use indexing if you know the key exists request.form.get('name') - use get if the key might not exist request.form.getlist('name') - use getlist if the key is sent multiple times and you want a list of values. get only returns the first value. \ud83d\udcc3 StackOverflow Let's try this! Create form.html on your templates/ dir Create one view function that returns only HTML form. Then, we will create a view function for handling simple POST requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- form.html --> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < form action = \"/submit\" method = \"post\" > < input type = \"text\" name = \"name\" /> < button type = \"submit\" > Send </ button > </ form > </ body > </ html > action - endpoint that we want to send request method - We will use HTTP POST for sending something. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from flask import Flask from flask import render_template from flask import request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"GET\" ]) def form (): return render_template ( \"form.html\" ) @app . route ( \"/submit\" , methods = [ \"POST\" ]) def submit (): data = request . form # get request form data name = data . get ( \"name\" ) # get name's value from this form return { \"message\" : f \"Hello { name } \u2728\" } # return something if __name__ == \"__main__\" : app . run () Only HTTP POST methods are allowed in the submit view. It works \ud83d\ude01\ud83c\udf89 This is the end of our simple flask basics tutorial \ud83d\ude0a","title":"Handling HTTP Requests"},{"location":"flask_tutorials/request_handling/#handling-http-requests","text":"There is a flask's Request class that very helps to handle users' requests. You have to import just a request from flask . 1 from flask import request By writing . after request you will see all methods and attributes of the request object in your editor: flask.request request.data Contains the incoming request data as a string in case it came with a mime-type Flask does not handle. request.args - the key/value pairs in the URL query string request.form - the key/value pairs in the body, from a HTML post form, or JavaScript - request that isn't JSON encoded request.files - the files in the body, which Flask keeps separate from form. HTML forms must use enctype=multipart/form-data or files will not be uploaded. request.values - combined args and form, preferring args if keys overlap request.json - parsed JSON data. The request must have the application/json content type, or use request.get_json(force=True) to ignore the content type. All of these are MultiDict instances (except for json). You can access values using: request.form['name'] - use indexing if you know the key exists request.form.get('name') - use get if the key might not exist request.form.getlist('name') - use getlist if the key is sent multiple times and you want a list of values. get only returns the first value. \ud83d\udcc3 StackOverflow Let's try this! Create form.html on your templates/ dir Create one view function that returns only HTML form. Then, we will create a view function for handling simple POST requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- form.html --> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < form action = \"/submit\" method = \"post\" > < input type = \"text\" name = \"name\" /> < button type = \"submit\" > Send </ button > </ form > </ body > </ html > action - endpoint that we want to send request method - We will use HTTP POST for sending something. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from flask import Flask from flask import render_template from flask import request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"GET\" ]) def form (): return render_template ( \"form.html\" ) @app . route ( \"/submit\" , methods = [ \"POST\" ]) def submit (): data = request . form # get request form data name = data . get ( \"name\" ) # get name's value from this form return { \"message\" : f \"Hello { name } \u2728\" } # return something if __name__ == \"__main__\" : app . run () Only HTTP POST methods are allowed in the submit view. It works \ud83d\ude01\ud83c\udf89 This is the end of our simple flask basics tutorial \ud83d\ude0a","title":"Handling HTTP Requests"},{"location":"flask_tutorials/routing/","text":"Routing The route that we wrote in the previous tutorial, is Static Route . If we want to create a profile page for our users, our web service should generate URLs of their profiles dynamically. We cannot solve this by using static routes. We have to create dynamic routes (variable rules ...) Simple logic for profile page: 1 2 3 4 # users/:user_id def profile_view ( user_id ): # logic ... For these dynamic routes, we should write the dynamic URL rules like this: 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask app = Flask ( __name__ ) @app . route ( \"/users/<user_id>\" ) def profile_view ( user_id ): return { \"message\" : f \"\ud83d\udc68\u200d\ud83d\udcbb USER_ID is { user_id } \" } if __name__ == \"__main__\" : app . run () By defining our URL rule within < ... > , it indicates a variable. They can be type-checked by adding a colon( : ). There are data types that routes can accept: Variable Rules string - (default) accepts any text without a slash int - accepts positive integers float - accepts positive floating point values path - like string but also accepts slashes uuid -accepts UUID strings Variable Rules should be given as the view function's argument. ProTips You can handle multiple routes with a single function by simply stacking additional route decorators above any route! 1 2 3 4 5 @app . route ( \"/\" ) @app . route ( \"/home\" ) @app . route ( \"/something\" ) def home (): return \"Hello Bro \ud83d\udc4b\"","title":"Routing"},{"location":"flask_tutorials/routing/#routing","text":"The route that we wrote in the previous tutorial, is Static Route . If we want to create a profile page for our users, our web service should generate URLs of their profiles dynamically. We cannot solve this by using static routes. We have to create dynamic routes (variable rules ...) Simple logic for profile page: 1 2 3 4 # users/:user_id def profile_view ( user_id ): # logic ... For these dynamic routes, we should write the dynamic URL rules like this: 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask app = Flask ( __name__ ) @app . route ( \"/users/<user_id>\" ) def profile_view ( user_id ): return { \"message\" : f \"\ud83d\udc68\u200d\ud83d\udcbb USER_ID is { user_id } \" } if __name__ == \"__main__\" : app . run () By defining our URL rule within < ... > , it indicates a variable. They can be type-checked by adding a colon( : ). There are data types that routes can accept: Variable Rules string - (default) accepts any text without a slash int - accepts positive integers float - accepts positive floating point values path - like string but also accepts slashes uuid -accepts UUID strings Variable Rules should be given as the view function's argument. ProTips You can handle multiple routes with a single function by simply stacking additional route decorators above any route! 1 2 3 4 5 @app . route ( \"/\" ) @app . route ( \"/home\" ) @app . route ( \"/something\" ) def home (): return \"Hello Bro \ud83d\udc4b\"","title":"Routing"},{"location":"flask_tutorials/running_application/","text":"Running Application For running this application, we can use Flask 's run method. But we should write this line of code on if __name__ == \"__main__\" statement. Why ?! if \"__name__\" == \"__main__\" ? Short Answer : this is the part that runs when the script is run from the CLI. freeCodeCamp StackOverflow 1 2 3 4 # ... if __name__ == \"__main__\" : app . run () Development Server Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see deployment for WSGI server recommendations ... 1 2 # read from here \ud83d\udc47 >>> Flask . run . __doc__ 1 $ python <my_module>.py Another ways of running Flask app Running from terminal : 1 2 $ export FLASK_APP = <module_name> $ flask run module_name - if your file's name is server.py , you should write server flask run - flask has its built-in CLI \ud83d\udd25 Reference: Flask CLI You can set environments for your flask apps. If the environment is set to development , the flask command will enable debug mode and flask run will enable the interactive debugger and reloader . 1 2 3 $ export FLASK_ENV = development $ export FLASK_APP = <module_name> $ flask run You do this in your code by passing debug=True in the run method: 1 app . run ( debug = True ) Gunicorn \ud83e\udd84 Gunicorn Gunicorn is a WSGI HTTP server for UNIX \ud83d\udc27 You cannot use gunicorn server on your windows. But you will be able to run your applications by gunicorn using docker containers or WSL (windows subsystem for Linux) Installation 1 $ pip install gunicorn Running application: 1 $ gunicorn -w <workers> <your_module>:<your_app> workers - it is good that settings workers number by this formula: workers = CPU_CORE * 2 + 1 your_module - if you wrote flask app's code in file.py , you should write file your_app - if you defined your flask app as app in file.py , you should write app` 1 $ gunicorn -w 9 file:app","title":"Running Application"},{"location":"flask_tutorials/running_application/#running-application","text":"For running this application, we can use Flask 's run method. But we should write this line of code on if __name__ == \"__main__\" statement. Why ?! if \"__name__\" == \"__main__\" ? Short Answer : this is the part that runs when the script is run from the CLI. freeCodeCamp StackOverflow 1 2 3 4 # ... if __name__ == \"__main__\" : app . run () Development Server Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see deployment for WSGI server recommendations ... 1 2 # read from here \ud83d\udc47 >>> Flask . run . __doc__ 1 $ python <my_module>.py","title":"Running Application"},{"location":"flask_tutorials/running_application/#another-ways-of-running-flask-app","text":"Running from terminal : 1 2 $ export FLASK_APP = <module_name> $ flask run module_name - if your file's name is server.py , you should write server flask run - flask has its built-in CLI \ud83d\udd25 Reference: Flask CLI You can set environments for your flask apps. If the environment is set to development , the flask command will enable debug mode and flask run will enable the interactive debugger and reloader . 1 2 3 $ export FLASK_ENV = development $ export FLASK_APP = <module_name> $ flask run You do this in your code by passing debug=True in the run method: 1 app . run ( debug = True )","title":"Another ways of running Flask app"},{"location":"flask_tutorials/running_application/#gunicorn","text":"Gunicorn Gunicorn is a WSGI HTTP server for UNIX \ud83d\udc27 You cannot use gunicorn server on your windows. But you will be able to run your applications by gunicorn using docker containers or WSL (windows subsystem for Linux) Installation 1 $ pip install gunicorn Running application: 1 $ gunicorn -w <workers> <your_module>:<your_app> workers - it is good that settings workers number by this formula: workers = CPU_CORE * 2 + 1 your_module - if you wrote flask app's code in file.py , you should write file your_app - if you defined your flask app as app in file.py , you should write app` 1 $ gunicorn -w 9 file:app","title":"Gunicorn \ud83e\udd84"},{"location":"flask_tutorials/templates/","text":"Templates Jinja is a fast, expressive, extensible templating engine! Installation Jinja is already installed if you are installed flask \ud83d\ude00 Flask uses the Jinja template engine for rendering HTML files. By defining your Flask application, it sets the default path of templates dir ( it is templates/` ). Import render_template function from flask on your code. Create templates/ directory and any *.html file. Rendering Templates Give your template's name as an argument to the render_template function. 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" ) if __name__ == \"__main__\" : app . run () It works \ud83d\udc40 We can also pass variables from our python code to our templates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" , directory = app . template_folder ) if __name__ == \"__main__\" : app . run () You should write(use) passed variable in your template between curly braces: 1 2 3 4 5 6 7 8 9 10 11 12 13 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < code > Hello World \ud83d\udc4b </ code > < h2 > TEMPLATES_DIR: {{ directory }} </ h2 > </ body > </ html > Variables directory - the name of our variable that we want to pass. app.template_folder - flask app's default template dir.","title":"Templates"},{"location":"flask_tutorials/templates/#templates","text":"Jinja is a fast, expressive, extensible templating engine! Installation Jinja is already installed if you are installed flask \ud83d\ude00 Flask uses the Jinja template engine for rendering HTML files. By defining your Flask application, it sets the default path of templates dir ( it is templates/` ). Import render_template function from flask on your code. Create templates/ directory and any *.html file. Rendering Templates Give your template's name as an argument to the render_template function. 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" ) if __name__ == \"__main__\" : app . run () It works \ud83d\udc40 We can also pass variables from our python code to our templates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" , directory = app . template_folder ) if __name__ == \"__main__\" : app . run () You should write(use) passed variable in your template between curly braces: 1 2 3 4 5 6 7 8 9 10 11 12 13 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < code > Hello World \ud83d\udc4b </ code > < h2 > TEMPLATES_DIR: {{ directory }} </ h2 > </ body > </ html > Variables directory - the name of our variable that we want to pass. app.template_folder - flask app's default template dir.","title":"Templates"}]}