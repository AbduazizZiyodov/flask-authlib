{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \ud83d\udc4b Flask-Authlib \ud83d\udd10 Flask-Authlib - Authentication Library For Flask Web Framework \ud83d\udd25 Installation Create a virtual environment for your python project: 1 python -m venv env Virtual Environment The venv module provides support for creating lightweight \u201cvirtual environments\u201d with their site directories, optionally isolated from system site directories. Python docs - Creation of virtual environments Activate it: Bash/zsh Cmd Powershell Git Bash 1 $ source env/bin/activate 1 C:\\> env\\Scripts\\activate.bat 1 PS C :\\> < venv >\\ Scripts \\ Activate . ps1 Note On Microsoft Windows, it may be required to enable the Activate.ps1 script by setting the execution policy for the user. You can do this by issuing the following PowerShell command: 1 PS C :> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser From python docs 1 $ source env/Scripts/activate Install this library by using pip command: 1 $ pip install -U flask_authlib 1 2 3 4 5 6 7 8 9 10 11 $ pip show flask_authlib Name: Flask-Authlib Version: 1.5.0 Summary: Authentication library for Flask Web Framework Home-page: https://github.com/AbduazizZiyodov/flask-authlib Author: Abduaziz Ziyodov Author-email: abduaziz.ziyodov@mail.ru License: MIT Location: ... Requires: ... \u2728 Features Goal of Project To allow python developers to add authentication functionality with one line of code! Library adds built-in frontend and backend that implements authentication functionality to your flask application automatically. The login and registration pages are ready for use. After starting and initializing your flask application templates ( templates/ ) and static ( static/ ) files will be copied on your app's folder (if you want, you can change these files any time). Better customization! You can customize this library by its configs. There are three types of configs: Base config Templates config Alerts config (alert messages) Flask For Beginners If you are a beginner in flask development, you can learn the basics of the flask on the Flask For Beginners section \ud83d\ude42","title":"Intro"},{"location":"#welcome","text":"","title":"Welcome \ud83d\udc4b"},{"location":"#installation","text":"Create a virtual environment for your python project: 1 python -m venv env Virtual Environment The venv module provides support for creating lightweight \u201cvirtual environments\u201d with their site directories, optionally isolated from system site directories. Python docs - Creation of virtual environments Activate it: Bash/zsh Cmd Powershell Git Bash 1 $ source env/bin/activate 1 C:\\> env\\Scripts\\activate.bat 1 PS C :\\> < venv >\\ Scripts \\ Activate . ps1 Note On Microsoft Windows, it may be required to enable the Activate.ps1 script by setting the execution policy for the user. You can do this by issuing the following PowerShell command: 1 PS C :> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser From python docs 1 $ source env/Scripts/activate Install this library by using pip command: 1 $ pip install -U flask_authlib 1 2 3 4 5 6 7 8 9 10 11 $ pip show flask_authlib Name: Flask-Authlib Version: 1.5.0 Summary: Authentication library for Flask Web Framework Home-page: https://github.com/AbduazizZiyodov/flask-authlib Author: Abduaziz Ziyodov Author-email: abduaziz.ziyodov@mail.ru License: MIT Location: ... Requires: ...","title":"Installation"},{"location":"#features","text":"Goal of Project To allow python developers to add authentication functionality with one line of code! Library adds built-in frontend and backend that implements authentication functionality to your flask application automatically. The login and registration pages are ready for use. After starting and initializing your flask application templates ( templates/ ) and static ( static/ ) files will be copied on your app's folder (if you want, you can change these files any time). Better customization! You can customize this library by its configs. There are three types of configs: Base config Templates config Alerts config (alert messages) Flask For Beginners If you are a beginner in flask development, you can learn the basics of the flask on the Flask For Beginners section \ud83d\ude42","title":"\u2728 Features"},{"location":"flask_tutorials/getting_started/","text":"Getting Started Flask is the best micro web framework written in Python \ud83d\udd25 Installation 1 $ pip install -U flask Open your favourite code editor \ud83d\ude0d Create a new *.py file \u2705 Import Flask from the flask framework and define your app: 1 2 3 from flask import Flask app = Flask ( __name__ ) __name__ is the import name for our flask app Create simple view function that returns simple text/html response: 1 2 3 4 5 6 7 8 from flask import Flask app = Flask ( __name__ ) def home_view (): return \"Hello Bro \ud83d\udc4b\" Next, you will should add this view function on your app's url rules. For this, we have to use Flask 's add_url_rule method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from flask import Flask app = Flask ( __name__ ) def home_view (): return \"Hello Bro \ud83d\udc4b\" app . add_url_rule ( rule = \"/\" , view_func = home_view ) flask.Flask.add_url_rule rule should be str view should be function or class For class based views, Flask has as_view method. Routes The method of add_url_rule is used by flask developers very rarely. They use route decorator instead of using add_url_rule and it provides to assign URLs in our app to functions easily. 1 2 3 @app . route ( \"/\" ) def home_view (): return \"Hello Bro \ud83d\udc4b\" \"/\" - url that our view function returns response. route decorator also uses from add_url_rule method : From flask's source code You can return any of the string and binary related types: str , unicode , bytes , bytearray , or if you prefer, you can return an already built response object: 1 2 3 4 5 6 7 from flask import Response app = Flask ( __name__ ) @app . route ( \"/\" ) def function (): return Response ( ... ) View Functions The names we chose for our view functions should be unique. 1 2 3 4 5 6 7 8 9 10 @app . route ( \"/\" ) def home (): return \"Hello!\" @app . route ( \"/home\" ) def home (): return \"Hello from home_2!\" # AssertionError: # View function mapping is overwriting an existing endpoint function: :view_function_name:","title":"Getting Started"},{"location":"flask_tutorials/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"flask_tutorials/http_methods/","text":"HTTP methods We can set specific HTTP methods to our routes. Add methods to the list that you want and give this methods list as route decorator's arguments with methods key ( methods = [ ...] ). For example, you want to allow only the HTTP POST method on your specific route, then you should add POST on methods like this: 1 2 3 @app . route ( \"/\" , methods = [ \"POST\" ]) def home_view (): return \"Hello Bro \ud83d\udc4b\" \u2705 Yeah, we sent a GET request from the browser, but it is not allowed.","title":"HTTP methods"},{"location":"flask_tutorials/http_methods/#http-methods","text":"We can set specific HTTP methods to our routes. Add methods to the list that you want and give this methods list as route decorator's arguments with methods key ( methods = [ ...] ). For example, you want to allow only the HTTP POST method on your specific route, then you should add POST on methods like this: 1 2 3 @app . route ( \"/\" , methods = [ \"POST\" ]) def home_view (): return \"Hello Bro \ud83d\udc4b\" \u2705 Yeah, we sent a GET request from the browser, but it is not allowed.","title":"HTTP methods"},{"location":"flask_tutorials/request_handling/","text":"Handling HTTP Requests There is a flask's Request class that very helps to handle users' requests. You have to import just a request from flask . 1 from flask import request By writing . after request you will see all methods and attributes of the request object in your editor: flask.request request.data Contains the incoming request data as a string in case it came with a mime-type Flask does not handle. request.args - the key/value pairs in the URL query string request.form - the key/value pairs in the body, from a HTML post form, or JavaScript - request that isn't JSON encoded request.files - the files in the body, which Flask keeps separate from form. HTML forms must use enctype=multipart/form-data or files will not be uploaded. request.values - combined args and form, preferring args if keys overlap request.json - parsed JSON data. The request must have the application/json content type, or use request.get_json(force=True) to ignore the content type. All of these are MultiDict instances (except for json). You can access values using: request.form['name'] - use indexing if you know the key exists request.form.get('name') - use get if the key might not exist request.form.getlist('name') - use getlist if the key is sent multiple times and you want a list of values. get only returns the first value. \ud83d\udcc3 StackOverflow Let's try this! Create form.html on your templates/ dir Create one view function that returns only HTML form. Then, we will create a view function for handling simple POST requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- form.html --> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < form action = \"/submit\" method = \"post\" > < input type = \"text\" name = \"name\" /> < button type = \"submit\" > Send </ button > </ form > </ body > </ html > action - endpoint that we want to send request method - We will use HTTP POST for sending something. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from flask import Flask from flask import render_template from flask import request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"GET\" ]) def form (): return render_template ( \"form.html\" ) @app . route ( \"/submit\" , methods = [ \"POST\" ]) def submit (): data = request . form # get request form data name = data . get ( \"name\" ) # get name's value from this form return { \"message\" : f \"Hello { name } \u2728\" } # return something if __name__ == \"__main__\" : app . run () Only HTTP POST methods are allowed in the submit view. It works \ud83d\ude01\ud83c\udf89 This is the end of our simple flask basics tutorial \ud83d\ude0a","title":"Handling HTTP Requests"},{"location":"flask_tutorials/request_handling/#handling-http-requests","text":"There is a flask's Request class that very helps to handle users' requests. You have to import just a request from flask . 1 from flask import request By writing . after request you will see all methods and attributes of the request object in your editor: flask.request request.data Contains the incoming request data as a string in case it came with a mime-type Flask does not handle. request.args - the key/value pairs in the URL query string request.form - the key/value pairs in the body, from a HTML post form, or JavaScript - request that isn't JSON encoded request.files - the files in the body, which Flask keeps separate from form. HTML forms must use enctype=multipart/form-data or files will not be uploaded. request.values - combined args and form, preferring args if keys overlap request.json - parsed JSON data. The request must have the application/json content type, or use request.get_json(force=True) to ignore the content type. All of these are MultiDict instances (except for json). You can access values using: request.form['name'] - use indexing if you know the key exists request.form.get('name') - use get if the key might not exist request.form.getlist('name') - use getlist if the key is sent multiple times and you want a list of values. get only returns the first value. \ud83d\udcc3 StackOverflow Let's try this! Create form.html on your templates/ dir Create one view function that returns only HTML form. Then, we will create a view function for handling simple POST requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- form.html --> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < form action = \"/submit\" method = \"post\" > < input type = \"text\" name = \"name\" /> < button type = \"submit\" > Send </ button > </ form > </ body > </ html > action - endpoint that we want to send request method - We will use HTTP POST for sending something. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from flask import Flask from flask import render_template from flask import request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"GET\" ]) def form (): return render_template ( \"form.html\" ) @app . route ( \"/submit\" , methods = [ \"POST\" ]) def submit (): data = request . form # get request form data name = data . get ( \"name\" ) # get name's value from this form return { \"message\" : f \"Hello { name } \u2728\" } # return something if __name__ == \"__main__\" : app . run () Only HTTP POST methods are allowed in the submit view. It works \ud83d\ude01\ud83c\udf89 This is the end of our simple flask basics tutorial \ud83d\ude0a","title":"Handling HTTP Requests"},{"location":"flask_tutorials/routing/","text":"Routing The route that we wrote in the previous tutorial, is Static Route . If we want to create a profile page for our users, our web service should generate URLs of their profiles dynamically. We cannot solve this by using static routes. We have to create dynamic routes (variable rules ...) Simple logic for profile page: 1 2 3 4 # users/:user_id def profile_view ( user_id ): # logic ... For these dynamic routes, we should write the dynamic URL rules like this: 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask app = Flask ( __name__ ) @app . route ( \"/users/<user_id>\" ) def profile_view ( user_id ): return { \"message\" : f \"\ud83d\udc68\u200d\ud83d\udcbb USER_ID is { user_id } \" } if __name__ == \"__main__\" : app . run () By defining our URL rule within < ... > , it indicates a variable. They can be type-checked by adding a colon( : ). There are data types that routes can accept: Variable Rules string - (default) accepts any text without a slash int - accepts positive integers float - accepts positive floating point values path - like string but also accepts slashes uuid -accepts UUID strings Variable Rules should be given as the view function's argument. ProTips You can handle multiple routes with a single function by simply stacking additional route decorators above any route! 1 2 3 4 5 @app . route ( \"/\" ) @app . route ( \"/home\" ) @app . route ( \"/something\" ) def home (): return \"Hello Bro \ud83d\udc4b\"","title":"Routing"},{"location":"flask_tutorials/routing/#routing","text":"The route that we wrote in the previous tutorial, is Static Route . If we want to create a profile page for our users, our web service should generate URLs of their profiles dynamically. We cannot solve this by using static routes. We have to create dynamic routes (variable rules ...) Simple logic for profile page: 1 2 3 4 # users/:user_id def profile_view ( user_id ): # logic ... For these dynamic routes, we should write the dynamic URL rules like this: 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask app = Flask ( __name__ ) @app . route ( \"/users/<user_id>\" ) def profile_view ( user_id ): return { \"message\" : f \"\ud83d\udc68\u200d\ud83d\udcbb USER_ID is { user_id } \" } if __name__ == \"__main__\" : app . run () By defining our URL rule within < ... > , it indicates a variable. They can be type-checked by adding a colon( : ). There are data types that routes can accept: Variable Rules string - (default) accepts any text without a slash int - accepts positive integers float - accepts positive floating point values path - like string but also accepts slashes uuid -accepts UUID strings Variable Rules should be given as the view function's argument. ProTips You can handle multiple routes with a single function by simply stacking additional route decorators above any route! 1 2 3 4 5 @app . route ( \"/\" ) @app . route ( \"/home\" ) @app . route ( \"/something\" ) def home (): return \"Hello Bro \ud83d\udc4b\"","title":"Routing"},{"location":"flask_tutorials/running_application/","text":"Running Application For running this application, we can use Flask 's run method. But we should write this line of code on if __name__ == \"__main__\" statement. Why ?! if \"__name__\" == \"__main__\" ? Short Answer : this is the part that runs when the script is run from the CLI. freeCodeCamp StackOverflow 1 2 3 4 # ... if __name__ == \"__main__\" : app . run () Development Server Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see deployment for WSGI server recommendations ... 1 2 # read from here \ud83d\udc47 >>> Flask . run . __doc__ 1 $ python <my_module>.py Another ways of running Flask app Running from terminal : 1 2 $ export FLASK_APP = <module_name> $ flask run module_name - if your file's name is server.py , you should write server flask run - flask has its built-in CLI \ud83d\udd25 Reference: Flask CLI You can set environments for your flask apps. If the environment is set to development , the flask command will enable debug mode and flask run will enable the interactive debugger and reloader . 1 2 3 $ export FLASK_ENV = development $ export FLASK_APP = <module_name> $ flask run You do this in your code by passing debug=True in the run method: 1 app . run ( debug = True ) Gunicorn \ud83e\udd84 Gunicorn Gunicorn is a WSGI HTTP server for UNIX \ud83d\udc27 You cannot use gunicorn server on your windows. But you will be able to run your applications by gunicorn using docker containers or WSL (windows subsystem for Linux) Installation 1 $ pip install gunicorn Running application: 1 $ gunicorn -w <workers> <your_module>:<your_app> workers - it is good that settings workers number by this formula: workers = CPU_CORE * 2 + 1 your_module - if you wrote flask app's code in file.py , you should write file your_app - if you defined your flask app as app in file.py , you should write app` 1 $ gunicorn -w 9 file:app","title":"Running Application"},{"location":"flask_tutorials/running_application/#running-application","text":"For running this application, we can use Flask 's run method. But we should write this line of code on if __name__ == \"__main__\" statement. Why ?! if \"__name__\" == \"__main__\" ? Short Answer : this is the part that runs when the script is run from the CLI. freeCodeCamp StackOverflow 1 2 3 4 # ... if __name__ == \"__main__\" : app . run () Development Server Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see deployment for WSGI server recommendations ... 1 2 # read from here \ud83d\udc47 >>> Flask . run . __doc__ 1 $ python <my_module>.py","title":"Running Application"},{"location":"flask_tutorials/running_application/#another-ways-of-running-flask-app","text":"Running from terminal : 1 2 $ export FLASK_APP = <module_name> $ flask run module_name - if your file's name is server.py , you should write server flask run - flask has its built-in CLI \ud83d\udd25 Reference: Flask CLI You can set environments for your flask apps. If the environment is set to development , the flask command will enable debug mode and flask run will enable the interactive debugger and reloader . 1 2 3 $ export FLASK_ENV = development $ export FLASK_APP = <module_name> $ flask run You do this in your code by passing debug=True in the run method: 1 app . run ( debug = True )","title":"Another ways of running Flask app"},{"location":"flask_tutorials/running_application/#gunicorn","text":"Gunicorn Gunicorn is a WSGI HTTP server for UNIX \ud83d\udc27 You cannot use gunicorn server on your windows. But you will be able to run your applications by gunicorn using docker containers or WSL (windows subsystem for Linux) Installation 1 $ pip install gunicorn Running application: 1 $ gunicorn -w <workers> <your_module>:<your_app> workers - it is good that settings workers number by this formula: workers = CPU_CORE * 2 + 1 your_module - if you wrote flask app's code in file.py , you should write file your_app - if you defined your flask app as app in file.py , you should write app` 1 $ gunicorn -w 9 file:app","title":"Gunicorn \ud83e\udd84"},{"location":"flask_tutorials/templates/","text":"Templates Jinja is a fast, expressive, extensible templating engine! Installation Jinja is already installed if you are installed flask \ud83d\ude00 Flask uses the Jinja template engine for rendering HTML files. By defining your Flask application, it sets the default path of templates dir ( it is templates/` ). Import render_template function from flask on your code. Create templates/ directory and any *.html file. Rendering Templates Give your template's name as an argument to the render_template function. 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" ) if __name__ == \"__main__\" : app . run () It works \ud83d\udc40 We can also pass variables from our python code to our templates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" , directory = app . template_folder ) if __name__ == \"__main__\" : app . run () You should write(use) passed variable in your template between curly braces: 1 2 3 4 5 6 7 8 9 10 11 12 13 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < code > Hello World \ud83d\udc4b </ code > < h2 > TEMPLATES_DIR: {{ directory }} </ h2 > </ body > </ html > Variables directory - the name of our variable that we want to pass. app.template_folder - flask app's default template dir.","title":"Templates"},{"location":"flask_tutorials/templates/#templates","text":"Jinja is a fast, expressive, extensible templating engine! Installation Jinja is already installed if you are installed flask \ud83d\ude00 Flask uses the Jinja template engine for rendering HTML files. By defining your Flask application, it sets the default path of templates dir ( it is templates/` ). Import render_template function from flask on your code. Create templates/ directory and any *.html file. Rendering Templates Give your template's name as an argument to the render_template function. 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" ) if __name__ == \"__main__\" : app . run () It works \ud83d\udc40 We can also pass variables from our python code to our templates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" , directory = app . template_folder ) if __name__ == \"__main__\" : app . run () You should write(use) passed variable in your template between curly braces: 1 2 3 4 5 6 7 8 9 10 11 12 13 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < code > Hello World \ud83d\udc4b </ code > < h2 > TEMPLATES_DIR: {{ directory }} </ h2 > </ body > </ html > Variables directory - the name of our variable that we want to pass. app.template_folder - flask app's default template dir.","title":"Templates"},{"location":"user-guide/alerts_config/","text":"flask_authlib.Alerts - simple configuration that stores alert messages. It is pretty easy that customizing alert messages! Alert object from source code of this library: 1 2 3 4 5 6 7 8 9 10 11 12 class Alerts : EMAIL_ALERT : str = \"This email is already taken!\" USERNAME_ALERT : str = \"This username is already taken!\" REGISTER_SUCCESS : str = \"Registration was successful!\" LOGIN_FAIL : str = \"The username or password is incorrect!\" REGISTER_FAIL : str = \"This email and username are already taken!\" BAD_REQUEST : str = \"Bad request!\" REQUIRED_FIELD : str = \"Please, fill in all required fields!\" Customizing alerts is very same as BaseConfig . Import it, change the values that you want and give your settings object as an argument to Auth again! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import Auth from flask_authlib import Alerts app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) class MyAlerts ( Alerts ): pass auth = Auth ( app , db , alerts = MyAlerts ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () I want to change email and username alerts message: 1 2 3 class MyAlerts ( Alerts ): EMAIL_ALERT = \"if emails.filter(your_email): stop_world()\" USERNAME_ALERT = \"Check your username from our database by SQL injection.\" Or, you can change login_fail 's alert message: 1 2 class MyAlerts ( Alerts ): LOGIN_FAIL = \"Get your password from database and decode it!\" \ud83c\udf89","title":"Customize Alerts"},{"location":"user-guide/base_config/","text":"flask_authlib.BaseConfig - contains core settings of the library. Default values of this object: 1 2 3 4 5 6 7 8 9 HOME_URL : str = \"/\" LOGIN_URL : str = \"/login\" REGISTER_URL : str = \"/register\" LOGOUT_URL : str = \"/logout\" LOGIN_MESSAGE_CATEGORY = \"info\" MIN_PASSWORD_LENGTH : int = 8 EMAIL_UNIQUE : bool = True HOME_URL - home page URL LOGIN_URL - login page URL REGISTER_URL : register page URL LOGOUT_URL - logout URL LOGIN_MESSAGE_CATEGORY - login message category ( flash message ), it is required by flask_login MIN_PASSWORD_LENGTH - minimum password length, it will be used in registration process. EMAIL_UNIQUE - if it is true , users' email will be validated for uniquennes in the register process. Customizing Base Config Basic Application: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import Auth app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) auth = Auth ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () Import BaseConfig from flask_authlib and create a python class that will describe your custom settings: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import Auth from flask_authlib import BaseConfig app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) class MySettings ( BaseConfig ): pass auth = Auth ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () Settings There are also some settings that I do not recommend changing: TEMPLATES_FOLDER_NAME and others that I have not written above. Let's customize settings: 1 2 3 4 5 class MySettings ( BaseConfig ): LOGIN_URL = \"/auth/login\" REGISTER_URL = \"/auth/register\" LOGOUT_URL : str = \"/auth/logout\" MIN_PASSWORD_LENGTH = 12 Now, after customizing we can give our settings object as argument( configs are Optional ) to the Auth class: 1 2 3 4 5 6 7 class MySettings ( BaseConfig ): LOGIN_URL = \"/auth/login\" REGISTER_URL = \"/auth/register\" LOGOUT_URL = \"/auth/logout\" MIN_PASSWORD_LENGTH = 12 auth = Auth ( app , db , base_config = MySettings ) Navigate to /login : Yeah, we changed login URL and we should navigate /auth/login : Check register URL: Check password length: Check password length validation: Check register functionality: Check logout URL after login: HTTP 302 If we navigate /auth/logout , the built-in logout view clears all sessions and will redirect us to HOME_PAGE .","title":"Customize Base Settings"},{"location":"user-guide/base_config/#customizing-base-config","text":"Basic Application: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import Auth app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) auth = Auth ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () Import BaseConfig from flask_authlib and create a python class that will describe your custom settings: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import Auth from flask_authlib import BaseConfig app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) class MySettings ( BaseConfig ): pass auth = Auth ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () Settings There are also some settings that I do not recommend changing: TEMPLATES_FOLDER_NAME and others that I have not written above. Let's customize settings: 1 2 3 4 5 class MySettings ( BaseConfig ): LOGIN_URL = \"/auth/login\" REGISTER_URL = \"/auth/register\" LOGOUT_URL : str = \"/auth/logout\" MIN_PASSWORD_LENGTH = 12 Now, after customizing we can give our settings object as argument( configs are Optional ) to the Auth class: 1 2 3 4 5 6 7 class MySettings ( BaseConfig ): LOGIN_URL = \"/auth/login\" REGISTER_URL = \"/auth/register\" LOGOUT_URL = \"/auth/logout\" MIN_PASSWORD_LENGTH = 12 auth = Auth ( app , db , base_config = MySettings ) Navigate to /login : Yeah, we changed login URL and we should navigate /auth/login : Check register URL: Check password length: Check password length validation: Check register functionality: Check logout URL after login: HTTP 302 If we navigate /auth/logout , the built-in logout view clears all sessions and will redirect us to HOME_PAGE .","title":"Customizing Base Config"},{"location":"user-guide/basic_usage/","text":"Flask-Authlib uses SQLAlchemy (sqlalchemy extension for flask) for the database part. After installation this ORM, you should import Auth and use it like this: 1 2 3 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import Auth Define your Flask application , db and Auth base object: 1 2 3 4 5 6 7 8 9 10 11 12 13 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import Auth app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) auth = Auth ( app , db ) flask_authlib.Auth Auth takes two arguments(required): app (Flask App) and db (SQLAlchemy). Add simple route and protect it by flask login's login_required decorator for testing login functionality: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import Auth app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) auth = Auth ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () If we try to navigate /protected , it should navigate us to the login page. That is why we used flask_login's @login_required . Next, run your flask application and you will see magic things \ud83d\ude02 (navigate to protected route): Login Page Register Page Tada \ud83c\udf89 If we look our application's directory, we can see new folders which are created by flask_authlib : static/ - stores static files ( js , css , fonts ... ) templates/ - stores *.html files","title":"Basic Usage of Library"},{"location":"user-guide/templates_config/","text":"flask_authlib.TemplateConfig - pages' labels, titles, buttons' colours are stored in this object. TemplateConfig object from source code of this library: 1 2 3 4 5 6 7 8 9 10 11 12 class TemplateConfig : USERNAME_LABEL : str = \"Username\" PASSWORD_LABEL : str = \"Password\" EMAIL_LABEL : str = \"Email address\" LOGIN_TITLE : str = \"Login\" LOGIN_BTN_TEXT : str = \"Login\" LOGIN_PRIMARY_COLOR : str = \"red\" REGISTER_TITLE : str = \"Register\" REGISTER_BTN_TEXT : str = \"Register\" REGISTER_PRIMARY_COLOR : str = \"yellow\" Customizing login and register page's title, login page's primary colour and username label's text content: 1 2 3 4 5 6 7 8 9 10 11 from flask_authlib import TemplateConfig class MyTemplateConfig ( TemplateConfig ): USERNAME_LABEL = \"Your instagram username\" LOGIN_TITLE = \"Welcome!\" REGISTER_TITLE = \"Welcome!\" LOGIN_PRIMARY_COLOR = \"blue\" REGISTER_PRIMARY_COLOR = \"green\" LOGIN_BTN_TEXT : str = \"Send\" REGISTER_BTN_TEXT : str = \"Send\" Login Page: Register Page: Primary Color Primary colour sets the colour of the button and the title. There are List of all primary colors : Blue Violet Green Red Yellow White Black","title":"Customize Templates"}]}