{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \ud83d\udc4b Flask-Authlib \ud83d\udd10 Flask-Authlib - Authentication Library For Flask Web Framework \ud83d\udd25 Installation Create a virtual environment for your python project: 1 python -m venv env Virtual Environment The venv module provides support for creating lightweight \u201cvirtual environments\u201d with their site directories, optionally isolated from system site directories. Python docs - Creation of virtual environments Activate it: Bash/zsh Cmd Powershell Git Bash 1 $ source env/bin/activate 1 C:\\> env\\Scripts\\activate.bat 1 PS C :\\> < venv >\\ Scripts \\ Activate . ps1 Note On Microsoft Windows, it may be required to enable the Activate.ps1 script by setting the execution policy for the user. You can do this by issuing the following PowerShell command: 1 PS C :> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser From python docs 1 $ source env/Scripts/activate Install this library by using pip command: 1 $ pip install -U flask_authlib 1 2 3 4 5 6 7 8 9 10 11 $ pip show flask_authlib Name: Flask-Authlib Version: 1.5.0 Summary: Authentication library for Flask Web Framework Home-page: https://github.com/AbduazizZiyodov/flask-authlib Author: Abduaziz Ziyodov Author-email: abduaziz.ziyodov@mail.ru License: MIT Location: ... Requires: ... \u2728 Features Goal of Project To allow python developers to add authentication functionality with one line of code! Library adds built-in frontend and backend that implements authentication functionality to your flask application automatically. The login and registration pages are ready for use. After starting and initializing your flask application templates ( templates/ ) and static ( static/ ) files will be copied on your app's folder (if you want, you can change these files any time). Better customization! You can customize this library by its configs. There are three types of configs: Base config Templates config Alerts config (alert messages) Flask For Beginners If you are a beginner in flask development, you can learn the basics of the flask on the Flask For Beginners section \ud83d\ude42","title":"Intro"},{"location":"#welcome","text":"","title":"Welcome \ud83d\udc4b"},{"location":"#installation","text":"Create a virtual environment for your python project: 1 python -m venv env Virtual Environment The venv module provides support for creating lightweight \u201cvirtual environments\u201d with their site directories, optionally isolated from system site directories. Python docs - Creation of virtual environments Activate it: Bash/zsh Cmd Powershell Git Bash 1 $ source env/bin/activate 1 C:\\> env\\Scripts\\activate.bat 1 PS C :\\> < venv >\\ Scripts \\ Activate . ps1 Note On Microsoft Windows, it may be required to enable the Activate.ps1 script by setting the execution policy for the user. You can do this by issuing the following PowerShell command: 1 PS C :> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser From python docs 1 $ source env/Scripts/activate Install this library by using pip command: 1 $ pip install -U flask_authlib 1 2 3 4 5 6 7 8 9 10 11 $ pip show flask_authlib Name: Flask-Authlib Version: 1.5.0 Summary: Authentication library for Flask Web Framework Home-page: https://github.com/AbduazizZiyodov/flask-authlib Author: Abduaziz Ziyodov Author-email: abduaziz.ziyodov@mail.ru License: MIT Location: ... Requires: ...","title":"Installation"},{"location":"#features","text":"Goal of Project To allow python developers to add authentication functionality with one line of code! Library adds built-in frontend and backend that implements authentication functionality to your flask application automatically. The login and registration pages are ready for use. After starting and initializing your flask application templates ( templates/ ) and static ( static/ ) files will be copied on your app's folder (if you want, you can change these files any time). Better customization! You can customize this library by its configs. There are three types of configs: Base config Templates config Alerts config (alert messages) Flask For Beginners If you are a beginner in flask development, you can learn the basics of the flask on the Flask For Beginners section \ud83d\ude42","title":"\u2728 Features"},{"location":"flask_tutorials/getting_started/","text":"Getting Started Flask is the best micro web framework written in Python \ud83d\udd25 Installation 1 $ pip install -U flask Open your favourite code editor \ud83d\ude0d Create a new *.py file \u2705 Import Flask from the flask framework and define your app: 1 2 3 from flask import Flask app = Flask ( __name__ ) __name__ is the import name for our flask app Create simple view function that returns simple text/html response: 1 2 3 4 5 6 7 8 from flask import Flask app = Flask ( __name__ ) def home_view (): return \"Hello Bro \ud83d\udc4b\" Next, you will should add this view function on your app's url rules. For this, we have to use Flask 's add_url_rule method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from flask import Flask app = Flask ( __name__ ) def home_view (): return \"Hello Bro \ud83d\udc4b\" app . add_url_rule ( rule = \"/\" , view_func = home_view ) flask.Flask.add_url_rule rule should be str view should be function or class For class based views, Flask has as_view method. Routes The method of add_url_rule is used by flask developers very rarely. They use route decorator instead of using add_url_rule and it provides to assign URLs in our app to functions easily. 1 2 3 @app . route ( \"/\" ) def home_view (): return \"Hello Bro \ud83d\udc4b\" \"/\" - url that our view function returns response. route decorator also uses from add_url_rule method : From flask's source code You can return any of the string and binary related types: str , unicode , bytes , bytearray , or if you prefer, you can return an already built response object: 1 2 3 4 5 6 7 from flask import Response app = Flask ( __name__ ) @app . route ( \"/\" ) def function (): return Response ( ... ) View Functions The names we chose for our view functions should be unique. 1 2 3 4 5 6 7 8 9 10 @app . route ( \"/\" ) def home (): return \"Hello!\" @app . route ( \"/home\" ) def home (): return \"Hello from home_2!\" # AssertionError: # View function mapping is overwriting an existing endpoint function: :view_function_name:","title":"Getting Started"},{"location":"flask_tutorials/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"flask_tutorials/http_methods/","text":"HTTP methods We can set specific HTTP methods to our routes. Add methods to the list that you want and give this methods list as route decorator's arguments with methods key ( methods = [ ...] ). For example, you want to allow only the HTTP POST method on your specific route, then you should add POST on methods like this: 1 2 3 @app . route ( \"/\" , methods = [ \"POST\" ]) def home_view (): return \"Hello Bro \ud83d\udc4b\" \u2705 Yeah, we sent a GET request from the browser, but it is not allowed.","title":"HTTP methods"},{"location":"flask_tutorials/http_methods/#http-methods","text":"We can set specific HTTP methods to our routes. Add methods to the list that you want and give this methods list as route decorator's arguments with methods key ( methods = [ ...] ). For example, you want to allow only the HTTP POST method on your specific route, then you should add POST on methods like this: 1 2 3 @app . route ( \"/\" , methods = [ \"POST\" ]) def home_view (): return \"Hello Bro \ud83d\udc4b\" \u2705 Yeah, we sent a GET request from the browser, but it is not allowed.","title":"HTTP methods"},{"location":"flask_tutorials/request_handling/","text":"Handling HTTP Requests There is a flask's Request class that very helps to handle users' requests. You have to import just a request from flask . 1 from flask import request By writing . after request you will see all methods and attributes of the request object in your editor: flask.request request.data Contains the incoming request data as a string in case it came with a mime-type Flask does not handle. request.args - the key/value pairs in the URL query string request.form - the key/value pairs in the body, from a HTML post form, or JavaScript - request that isn't JSON encoded request.files - the files in the body, which Flask keeps separate from form. HTML forms must use enctype=multipart/form-data or files will not be uploaded. request.values - combined args and form, preferring args if keys overlap request.json - parsed JSON data. The request must have the application/json content type, or use request.get_json(force=True) to ignore the content type. All of these are MultiDict instances (except for json). You can access values using: request.form['name'] - use indexing if you know the key exists request.form.get('name') - use get if the key might not exist request.form.getlist('name') - use getlist if the key is sent multiple times and you want a list of values. get only returns the first value. \ud83d\udcc3 StackOverflow Let's try this! Create form.html on your templates/ dir Create one view function that returns only HTML form. Then, we will create a view function for handling simple POST requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- form.html --> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < form action = \"/submit\" method = \"post\" > < input type = \"text\" name = \"name\" /> < button type = \"submit\" > Send </ button > </ form > </ body > </ html > action - endpoint that we want to send request method - We will use HTTP POST for sending something. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from flask import Flask from flask import render_template from flask import request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"GET\" ]) def form (): return render_template ( \"form.html\" ) @app . route ( \"/submit\" , methods = [ \"POST\" ]) def submit (): data = request . form # get request form data name = data . get ( \"name\" ) # get name's value from this form return { \"message\" : f \"Hello { name } \u2728\" } # return something if __name__ == \"__main__\" : app . run () Only HTTP POST methods are allowed in the submit view. It works \ud83d\ude01\ud83c\udf89 This is the end of our simple flask basics tutorial \ud83d\ude0a","title":"Handling HTTP Requests"},{"location":"flask_tutorials/request_handling/#handling-http-requests","text":"There is a flask's Request class that very helps to handle users' requests. You have to import just a request from flask . 1 from flask import request By writing . after request you will see all methods and attributes of the request object in your editor: flask.request request.data Contains the incoming request data as a string in case it came with a mime-type Flask does not handle. request.args - the key/value pairs in the URL query string request.form - the key/value pairs in the body, from a HTML post form, or JavaScript - request that isn't JSON encoded request.files - the files in the body, which Flask keeps separate from form. HTML forms must use enctype=multipart/form-data or files will not be uploaded. request.values - combined args and form, preferring args if keys overlap request.json - parsed JSON data. The request must have the application/json content type, or use request.get_json(force=True) to ignore the content type. All of these are MultiDict instances (except for json). You can access values using: request.form['name'] - use indexing if you know the key exists request.form.get('name') - use get if the key might not exist request.form.getlist('name') - use getlist if the key is sent multiple times and you want a list of values. get only returns the first value. \ud83d\udcc3 StackOverflow Let's try this! Create form.html on your templates/ dir Create one view function that returns only HTML form. Then, we will create a view function for handling simple POST requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- form.html --> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < form action = \"/submit\" method = \"post\" > < input type = \"text\" name = \"name\" /> < button type = \"submit\" > Send </ button > </ form > </ body > </ html > action - endpoint that we want to send request method - We will use HTTP POST for sending something. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from flask import Flask from flask import render_template from flask import request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"GET\" ]) def form (): return render_template ( \"form.html\" ) @app . route ( \"/submit\" , methods = [ \"POST\" ]) def submit (): data = request . form # get request form data name = data . get ( \"name\" ) # get name's value from this form return { \"message\" : f \"Hello { name } \u2728\" } # return something if __name__ == \"__main__\" : app . run () Only HTTP POST methods are allowed in the submit view. It works \ud83d\ude01\ud83c\udf89 This is the end of our simple flask basics tutorial \ud83d\ude0a","title":"Handling HTTP Requests"},{"location":"flask_tutorials/routing/","text":"Routing The route that we wrote in the previous tutorial, is Static Route . If we want to create a profile page for our users, our web service should generate URLs of their profiles dynamically. We cannot solve this by using static routes. We have to create dynamic routes (variable rules ...) Simple logic for profile page: 1 2 3 4 # users/:user_id def profile_view ( user_id ): # logic ... For these dynamic routes, we should write the dynamic URL rules like this: 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask app = Flask ( __name__ ) @app . route ( \"/users/<user_id>\" ) def profile_view ( user_id ): return { \"message\" : f \"\ud83d\udc68\u200d\ud83d\udcbb USER_ID is { user_id } \" } if __name__ == \"__main__\" : app . run () By defining our URL rule within < ... > , it indicates a variable. They can be type-checked by adding a colon( : ). There are data types that routes can accept: Variable Rules string - (default) accepts any text without a slash int - accepts positive integers float - accepts positive floating point values path - like string but also accepts slashes uuid -accepts UUID strings Variable Rules should be given as the view function's argument. ProTips You can handle multiple routes with a single function by simply stacking additional route decorators above any route! 1 2 3 4 5 @app . route ( \"/\" ) @app . route ( \"/home\" ) @app . route ( \"/something\" ) def home (): return \"Hello Bro \ud83d\udc4b\"","title":"Routing"},{"location":"flask_tutorials/routing/#routing","text":"The route that we wrote in the previous tutorial, is Static Route . If we want to create a profile page for our users, our web service should generate URLs of their profiles dynamically. We cannot solve this by using static routes. We have to create dynamic routes (variable rules ...) Simple logic for profile page: 1 2 3 4 # users/:user_id def profile_view ( user_id ): # logic ... For these dynamic routes, we should write the dynamic URL rules like this: 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask app = Flask ( __name__ ) @app . route ( \"/users/<user_id>\" ) def profile_view ( user_id ): return { \"message\" : f \"\ud83d\udc68\u200d\ud83d\udcbb USER_ID is { user_id } \" } if __name__ == \"__main__\" : app . run () By defining our URL rule within < ... > , it indicates a variable. They can be type-checked by adding a colon( : ). There are data types that routes can accept: Variable Rules string - (default) accepts any text without a slash int - accepts positive integers float - accepts positive floating point values path - like string but also accepts slashes uuid -accepts UUID strings Variable Rules should be given as the view function's argument. ProTips You can handle multiple routes with a single function by simply stacking additional route decorators above any route! 1 2 3 4 5 @app . route ( \"/\" ) @app . route ( \"/home\" ) @app . route ( \"/something\" ) def home (): return \"Hello Bro \ud83d\udc4b\"","title":"Routing"},{"location":"flask_tutorials/running_application/","text":"Running Application For running this application, we can use Flask 's run method. But we should write this line of code on if __name__ == \"__main__\" statement. Why ?! if \"__name__\" == \"__main__\" ? Short Answer : this is the part that runs when the script is run from the CLI. freeCodeCamp StackOverflow 1 2 3 4 # ... if __name__ == \"__main__\" : app . run () Development Server Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see deployment for WSGI server recommendations ... 1 2 # read from here \ud83d\udc47 >>> Flask . run . __doc__ 1 $ python <my_module>.py Another ways of running Flask app Running from terminal : 1 2 $ export FLASK_APP = <module_name> $ flask run module_name - if your file's name is server.py , you should write server flask run - flask has its built-in CLI \ud83d\udd25 Reference: Flask CLI You can set environments for your flask apps. If the environment is set to development , the flask command will enable debug mode and flask run will enable the interactive debugger and reloader . 1 2 3 $ export FLASK_ENV = development $ export FLASK_APP = <module_name> $ flask run You do this in your code by passing debug=True in the run method: 1 app . run ( debug = True ) Gunicorn \ud83e\udd84 Gunicorn Gunicorn is a WSGI HTTP server for UNIX \ud83d\udc27 You cannot use gunicorn server on your windows. But you will be able to run your applications by gunicorn using docker containers or WSL (windows subsystem for Linux) Installation 1 $ pip install gunicorn Running application: 1 $ gunicorn -w <workers> <your_module>:<your_app> workers - it is good that settings workers number by this formula: workers = CPU_CORE * 2 + 1 your_module - if you wrote flask app's code in file.py , you should write file your_app - if you defined your flask app as app in file.py , you should write app` 1 $ gunicorn -w 9 file:app","title":"Running Application"},{"location":"flask_tutorials/running_application/#running-application","text":"For running this application, we can use Flask 's run method. But we should write this line of code on if __name__ == \"__main__\" statement. Why ?! if \"__name__\" == \"__main__\" ? Short Answer : this is the part that runs when the script is run from the CLI. freeCodeCamp StackOverflow 1 2 3 4 # ... if __name__ == \"__main__\" : app . run () Development Server Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see deployment for WSGI server recommendations ... 1 2 # read from here \ud83d\udc47 >>> Flask . run . __doc__ 1 $ python <my_module>.py","title":"Running Application"},{"location":"flask_tutorials/running_application/#another-ways-of-running-flask-app","text":"Running from terminal : 1 2 $ export FLASK_APP = <module_name> $ flask run module_name - if your file's name is server.py , you should write server flask run - flask has its built-in CLI \ud83d\udd25 Reference: Flask CLI You can set environments for your flask apps. If the environment is set to development , the flask command will enable debug mode and flask run will enable the interactive debugger and reloader . 1 2 3 $ export FLASK_ENV = development $ export FLASK_APP = <module_name> $ flask run You do this in your code by passing debug=True in the run method: 1 app . run ( debug = True )","title":"Another ways of running Flask app"},{"location":"flask_tutorials/running_application/#gunicorn","text":"Gunicorn Gunicorn is a WSGI HTTP server for UNIX \ud83d\udc27 You cannot use gunicorn server on your windows. But you will be able to run your applications by gunicorn using docker containers or WSL (windows subsystem for Linux) Installation 1 $ pip install gunicorn Running application: 1 $ gunicorn -w <workers> <your_module>:<your_app> workers - it is good that settings workers number by this formula: workers = CPU_CORE * 2 + 1 your_module - if you wrote flask app's code in file.py , you should write file your_app - if you defined your flask app as app in file.py , you should write app` 1 $ gunicorn -w 9 file:app","title":"Gunicorn \ud83e\udd84"},{"location":"flask_tutorials/templates/","text":"Templates Jinja is a fast, expressive, extensible templating engine! Installation Jinja is already installed if you are installed flask \ud83d\ude00 Flask uses the Jinja template engine for rendering HTML files. By defining your Flask application, it sets the default path of templates dir ( it is templates/` ). Import render_template function from flask on your code. Create templates/ directory and any *.html file. Rendering Templates Give your template's name as an argument to the render_template function. 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" ) if __name__ == \"__main__\" : app . run () It works \ud83d\udc40 We can also pass variables from our python code to our templates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" , directory = app . template_folder ) if __name__ == \"__main__\" : app . run () You should write(use) passed variable in your template between curly braces: 1 2 3 4 5 6 7 8 9 10 11 12 13 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < code > Hello World \ud83d\udc4b </ code > < h2 > TEMPLATES_DIR: {{ directory }} </ h2 > </ body > </ html > Variables directory - the name of our variable that we want to pass. app.template_folder - flask app's default template dir.","title":"Templates"},{"location":"flask_tutorials/templates/#templates","text":"Jinja is a fast, expressive, extensible templating engine! Installation Jinja is already installed if you are installed flask \ud83d\ude00 Flask uses the Jinja template engine for rendering HTML files. By defining your Flask application, it sets the default path of templates dir ( it is templates/` ). Import render_template function from flask on your code. Create templates/ directory and any *.html file. Rendering Templates Give your template's name as an argument to the render_template function. 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" ) if __name__ == \"__main__\" : app . run () It works \ud83d\udc40 We can also pass variables from our python code to our templates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from flask import Flask from flask import render_template app = Flask ( __name__ ) @app . route ( \"/\" ) def home_view (): return render_template ( \"home.html\" , directory = app . template_folder ) if __name__ == \"__main__\" : app . run () You should write(use) passed variable in your template between curly braces: 1 2 3 4 5 6 7 8 9 10 11 12 13 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > Title </ title > </ head > < body > < code > Hello World \ud83d\udc4b </ code > < h2 > TEMPLATES_DIR: {{ directory }} </ h2 > </ body > </ html > Variables directory - the name of our variable that we want to pass. app.template_folder - flask app's default template dir.","title":"Templates"},{"location":"jwt-guide/custom-user-model/","text":"Custom User Model Note Flask Authlib uses SQLAlchemy ORM on the database part. That means if you want to set your user model you should also use SQLAlchemy . Default User Model Code from flask_authlib.database.models.User : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class User ( db . Model , UserMixin ): __tablename__ = table_name __table_args__ = { 'extend_existing' : True } id = db . Column ( db . Integer , primary_key = True ) username = db . Column ( db . String , nullable = False ) email = db . Column ( db . String , nullable = False ) password_hash = db . Column ( db . String , nullable = False ) admin = db . Column ( db . Boolean , default = False ) def is_admin ( self ) -> bool : return self . admin def insert ( self ) -> None : db . session . add ( self ) db . session . commit () def to_dict ( self ): columns : list [ str ] = self . __table__ . columns . keys () return { key : getattr ( self , key ) for key in columns } Default User Schema(Pydantic) Code from flask_authlib.schemas.User : 1 2 3 4 5 6 class User ( BaseModel ): id : Optional [ int ] username : str email : EmailStr password_hash : str is_admin : bool User Model For customization database model, you should get the default user model and create your user model class based on the default user model: Getting default user model: 1 from flask_authlib import get_user_model as DefaultUserModel Create your user model. For example, I want to add the is_baby column on my user model: Make sure that you have created your flask app and database(DB). Don't forget about SQLALCHEMY_DATABASE_URI . 1 2 3 4 from flask_authlib import get_user_model as DefaultUserModel class CustomUser ( DefaultUserModel ( db , \"users\" )): is_baby = db . Column ( db . Boolean , default = False ) db and table_name arguments are required for get_user_model Next, you have to apply this user model. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import JWT from flask_authlib import get_user_model as DefaultUserModel app = Flask ( __name__ ) db = SQLAlchemy ( app ) class CustomUser ( DefaultUserModel ( db , \"users\" )): is_baby = db . Column ( db . Boolean , default = False ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = JWT ( app , db , UserModel = CustomUser ) app . add_url_rule ( rule = \"/\" , view_func = lambda : \"Hello World!\" ) app . run () User Schema If we use our modified model on this library, in the authentication process pydantic simply ignores new fields of our model. But why ?! We have changed user model , not user schema . Pydantic serializes data according to its schemas. We changed the user model, and now we must change the user schema. Get default user schema: 1 from flask_authlib import User Create your pydantic schema based on this User : 1 2 3 4 from typing import Optional class UserSchema ( User ): is_baby : Optional [ bool ] We have included our new field on this schema. Change default user schema from JwtConfig . For this, you should create your settings class. 1 2 3 4 from flask_authlib import JwtConfig class MyConfig ( JwtConfig ): user_schema : User = UserSchema Apply your settings: 1 auth = JWT ( app , db , UserModel = CustomUser , settings = MyConfig ) Run and test it! Code : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import User from flask_authlib import JWT from flask_authlib import JwtConfig from flask_authlib import get_user_model as DefaultUserModel app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" class CustomUser ( DefaultUserModel ( db , \"users\" )): is_baby = db . Column ( db . Boolean , default = False ) class UserSchema ( User ): is_baby : Optional [ bool ] class MyConfig ( JwtConfig ): user_schema : User = UserSchema auth = JWT ( app , db , UserModel = CustomUser , settings = MyConfig ) @app . route ( \"/\" ) @auth . jwt_required def home ( user : UserSchema ): return user . dict () app . run () \ud83d\udc4d","title":"User model"},{"location":"jwt-guide/custom-user-model/#custom-user-model","text":"Note Flask Authlib uses SQLAlchemy ORM on the database part. That means if you want to set your user model you should also use SQLAlchemy .","title":"Custom User Model"},{"location":"jwt-guide/custom-user-model/#default-user-model","text":"Code from flask_authlib.database.models.User : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class User ( db . Model , UserMixin ): __tablename__ = table_name __table_args__ = { 'extend_existing' : True } id = db . Column ( db . Integer , primary_key = True ) username = db . Column ( db . String , nullable = False ) email = db . Column ( db . String , nullable = False ) password_hash = db . Column ( db . String , nullable = False ) admin = db . Column ( db . Boolean , default = False ) def is_admin ( self ) -> bool : return self . admin def insert ( self ) -> None : db . session . add ( self ) db . session . commit () def to_dict ( self ): columns : list [ str ] = self . __table__ . columns . keys () return { key : getattr ( self , key ) for key in columns }","title":"Default User Model"},{"location":"jwt-guide/custom-user-model/#default-user-schemapydantic","text":"Code from flask_authlib.schemas.User : 1 2 3 4 5 6 class User ( BaseModel ): id : Optional [ int ] username : str email : EmailStr password_hash : str is_admin : bool","title":"Default User Schema(Pydantic)"},{"location":"jwt-guide/custom-user-model/#user-model","text":"For customization database model, you should get the default user model and create your user model class based on the default user model: Getting default user model: 1 from flask_authlib import get_user_model as DefaultUserModel Create your user model. For example, I want to add the is_baby column on my user model: Make sure that you have created your flask app and database(DB). Don't forget about SQLALCHEMY_DATABASE_URI . 1 2 3 4 from flask_authlib import get_user_model as DefaultUserModel class CustomUser ( DefaultUserModel ( db , \"users\" )): is_baby = db . Column ( db . Boolean , default = False ) db and table_name arguments are required for get_user_model Next, you have to apply this user model. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import JWT from flask_authlib import get_user_model as DefaultUserModel app = Flask ( __name__ ) db = SQLAlchemy ( app ) class CustomUser ( DefaultUserModel ( db , \"users\" )): is_baby = db . Column ( db . Boolean , default = False ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = JWT ( app , db , UserModel = CustomUser ) app . add_url_rule ( rule = \"/\" , view_func = lambda : \"Hello World!\" ) app . run ()","title":"User Model"},{"location":"jwt-guide/custom-user-model/#user-schema","text":"If we use our modified model on this library, in the authentication process pydantic simply ignores new fields of our model. But why ?! We have changed user model , not user schema . Pydantic serializes data according to its schemas. We changed the user model, and now we must change the user schema. Get default user schema: 1 from flask_authlib import User Create your pydantic schema based on this User : 1 2 3 4 from typing import Optional class UserSchema ( User ): is_baby : Optional [ bool ] We have included our new field on this schema. Change default user schema from JwtConfig . For this, you should create your settings class. 1 2 3 4 from flask_authlib import JwtConfig class MyConfig ( JwtConfig ): user_schema : User = UserSchema Apply your settings: 1 auth = JWT ( app , db , UserModel = CustomUser , settings = MyConfig ) Run and test it! Code : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import User from flask_authlib import JWT from flask_authlib import JwtConfig from flask_authlib import get_user_model as DefaultUserModel app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" class CustomUser ( DefaultUserModel ( db , \"users\" )): is_baby = db . Column ( db . Boolean , default = False ) class UserSchema ( User ): is_baby : Optional [ bool ] class MyConfig ( JwtConfig ): user_schema : User = UserSchema auth = JWT ( app , db , UserModel = CustomUser , settings = MyConfig ) @app . route ( \"/\" ) @auth . jwt_required def home ( user : UserSchema ): return user . dict () app . run () \ud83d\udc4d","title":"User Schema"},{"location":"jwt-guide/intro_to_jwt/","text":"\ud83d\udca1 JWT JSON Web Token ( JWT ) is an open standard ( RFC 7519 ) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA. Although JWTs can be encrypted to also provide secrecy between parties, we will focus on signed tokens. Signed tokens can verify the integrity of the claims contained within them, while encrypted tokens hide those claims from other parties. When tokens are signed using `public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it. Reference \ud83e\udd14 What is the JSON Web Token structure? In its compact form, JSON Web Tokens consist of three parts separated by dots (.), which are: Header Payload Signature Therefore, a JWT typically looks like the following: 1 xxxxx.yyyyy.zzzzz Joke: If you see that token starts with ey , you can say that it is a JWT token \ud83d\ude02 \u2728 How do JSON Web Tokens work? A very common use for JWT \u2014 and perhaps the only good one \u2014 is as an API authentication mechanism. Whenever the user wants to access a protected route or resource, the user agent should send the JWT, typically in the Authorization header using the Bearer schema. The content of the header should look like the following: By using python's requests library: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import requests jwt_token : str = \"ey...\" url = \"http://my-host.com/api/login\" request_body = { \"username\" : \"Abduaziz\" } headers = { \"Authorization\" : f \"Bearer { jwt_token } \" } response = requests . request ( \"POST\" , url , headers = headers , data = request_body ) print ( response . text ) When we send this request, the server: Tries to get Authorization from HTTP header. Decodes and checks the validity of this token. If there are errors with the token the server returns the HTTP 401 response to the client. JWT tokens have an expiration time. If the token has expired, users can't use it. If not, the server returns a successful response. \u2705 Permissions We can place user role & permissions (admin, user ...) on the JWT token. You can't access to admin resource when you send a valid JWT token that has user permission, not admin . Adding permissions to JWT can be done on the token encoding process. You should add permissions on the JWT token's payload. After that, by decoding this token you can get this payload. Example 1 2 3 4 5 { \"sub\" : \"1234567890\" , \"name\" : \"John Doe\" , \"admin\" : true } Libraries Reference to the libraries that help you work with JWT : https://jwt.io/libraries","title":"Intro to JWT"},{"location":"jwt-guide/intro_to_jwt/#jwt","text":"JSON Web Token ( JWT ) is an open standard ( RFC 7519 ) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA. Although JWTs can be encrypted to also provide secrecy between parties, we will focus on signed tokens. Signed tokens can verify the integrity of the claims contained within them, while encrypted tokens hide those claims from other parties. When tokens are signed using `public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it. Reference","title":"\ud83d\udca1 JWT"},{"location":"jwt-guide/intro_to_jwt/#what-is-the-json-web-token-structure","text":"In its compact form, JSON Web Tokens consist of three parts separated by dots (.), which are: Header Payload Signature Therefore, a JWT typically looks like the following: 1 xxxxx.yyyyy.zzzzz Joke: If you see that token starts with ey , you can say that it is a JWT token \ud83d\ude02","title":"\ud83e\udd14 What is the JSON Web Token structure?"},{"location":"jwt-guide/intro_to_jwt/#how-do-json-web-tokens-work","text":"A very common use for JWT \u2014 and perhaps the only good one \u2014 is as an API authentication mechanism. Whenever the user wants to access a protected route or resource, the user agent should send the JWT, typically in the Authorization header using the Bearer schema. The content of the header should look like the following: By using python's requests library: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import requests jwt_token : str = \"ey...\" url = \"http://my-host.com/api/login\" request_body = { \"username\" : \"Abduaziz\" } headers = { \"Authorization\" : f \"Bearer { jwt_token } \" } response = requests . request ( \"POST\" , url , headers = headers , data = request_body ) print ( response . text ) When we send this request, the server: Tries to get Authorization from HTTP header. Decodes and checks the validity of this token. If there are errors with the token the server returns the HTTP 401 response to the client. JWT tokens have an expiration time. If the token has expired, users can't use it. If not, the server returns a successful response.","title":"\u2728 How do JSON Web Tokens work?"},{"location":"jwt-guide/intro_to_jwt/#permissions","text":"We can place user role & permissions (admin, user ...) on the JWT token. You can't access to admin resource when you send a valid JWT token that has user permission, not admin . Adding permissions to JWT can be done on the token encoding process. You should add permissions on the JWT token's payload. After that, by decoding this token you can get this payload. Example 1 2 3 4 5 { \"sub\" : \"1234567890\" , \"name\" : \"John Doe\" , \"admin\" : true } Libraries Reference to the libraries that help you work with JWT : https://jwt.io/libraries","title":"\u2705 Permissions"},{"location":"jwt-guide/jwt-advanced-usage/","text":"Advanced usage of JWT \ud83d\udd10 Protecting Routes For protecting your API routes with JWT tokens you should use the jwt_required decorator on your view functions. It can handle any exceptions automatically. Basic application: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import JWT app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = JWT ( app , db ) @app . route ( \"/\" ) def home (): return { \"success\" : True } if __name__ == \"__main__\" : app . run () Using flask_authlib.JWT.jwt_required : 1 2 3 4 5 6 7 8 9 10 # .... auth = JWT ( app , db ) @app . route ( \"/\" ) @auth . jwt_required def home (): return { \"success\" : True } # ... \ud83e\uddeaTesting 1) The response should have 401 status We have not included the JWT token in your HTTP request header 2) The response should have 401 status We sent an invalid JWT token. 2) The response should have a 200 status Our JWT token is valid. It works, why\ud83d\ude02? \ud83e\uddd1 Get current user from JWT Another feature of this library is that you can easily get the user's credentials after the decoding process. You have to use the jwt_required decorator for protecting your API endpoint via JWT tokens. After that, if you want to get current_user from JWT, you should pass only one function argument with the name user . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import JWT app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = JWT ( app , db ) @app . route ( \"/\" ) @auth . jwt_required def home ( user ): return { \"message\" : str ( user )} if __name__ == \"__main__\" : app . run () Send GET request to our basic route: Bro, we have got something \ud83d\udc40 You can see user's info is included in the JWT token. You need not write a parser for serializing user info. We used str(user) above for not getting any exceptions related to response data type. You can use python's super, hyper debugger for getting the type of this data. This is the print . Just use print and type in your code like this: 1 2 3 4 5 6 7 ... @app . route ( \"/\" ) @auth . jwt_required def home ( user ): print ( type ( user )) return { \"message\" : str ( user )} ... Send GET request and look at your terminal: flask_authlib.schemas.User is pydantic model which is used for validating & serializing user credentials. You can use pydantic's features in your code. One of these features is dict method. This is not dict object on python, it is one of the useful methods of pydantic.BaseModel . BaseModel.dict Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Let's use it for converting our user credentials to python's dict object: 1 2 3 4 5 6 ... @app . route ( \"/\" ) @auth . jwt_required def home ( user ): return { \"message\" : user . dict ()} ... Yeah \ud83d\ude09 Type Annotations Another feature of pydantic is that you can use your pydantic models as type annotations. It is supported by many IDEs (I use vscode). For instance: We can't see any suggestions. Because we don't know the type of this function argument. For solving this task, we can use type annotations (we can use them everywhere). 1 2 3 4 5 6 # Defining Variable response : ResponseModel = client . post ( ** kwargs ) # Function and class methods' arguments def do_it ( self , data : dict ) -> List [ str ]: # `data` is `dict` object \ud83d\ude42 return list ( self . just_do_it ( data )) Use flask_authlib 's User model for annotating types on your code: Code 1 2 3 4 5 6 7 8 from flask_authlib import JWT , User ... @app . route ( \"/\" ) @auth . jwt_required def home ( user : User ): email = user . email return { \"message\" : user . dict ()} ...","title":"Advanced usage of JWT"},{"location":"jwt-guide/jwt-advanced-usage/#advanced-usage-of-jwt","text":"","title":"Advanced usage of JWT"},{"location":"jwt-guide/jwt-advanced-usage/#protecting-routes","text":"For protecting your API routes with JWT tokens you should use the jwt_required decorator on your view functions. It can handle any exceptions automatically. Basic application: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import JWT app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = JWT ( app , db ) @app . route ( \"/\" ) def home (): return { \"success\" : True } if __name__ == \"__main__\" : app . run () Using flask_authlib.JWT.jwt_required : 1 2 3 4 5 6 7 8 9 10 # .... auth = JWT ( app , db ) @app . route ( \"/\" ) @auth . jwt_required def home (): return { \"success\" : True } # ...","title":"\ud83d\udd10 Protecting Routes"},{"location":"jwt-guide/jwt-advanced-usage/#testing","text":"1) The response should have 401 status We have not included the JWT token in your HTTP request header 2) The response should have 401 status We sent an invalid JWT token. 2) The response should have a 200 status Our JWT token is valid. It works, why\ud83d\ude02?","title":"\ud83e\uddeaTesting"},{"location":"jwt-guide/jwt-advanced-usage/#get-current-user-from-jwt","text":"Another feature of this library is that you can easily get the user's credentials after the decoding process. You have to use the jwt_required decorator for protecting your API endpoint via JWT tokens. After that, if you want to get current_user from JWT, you should pass only one function argument with the name user . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import JWT app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = JWT ( app , db ) @app . route ( \"/\" ) @auth . jwt_required def home ( user ): return { \"message\" : str ( user )} if __name__ == \"__main__\" : app . run () Send GET request to our basic route: Bro, we have got something \ud83d\udc40 You can see user's info is included in the JWT token. You need not write a parser for serializing user info. We used str(user) above for not getting any exceptions related to response data type. You can use python's super, hyper debugger for getting the type of this data. This is the print . Just use print and type in your code like this: 1 2 3 4 5 6 7 ... @app . route ( \"/\" ) @auth . jwt_required def home ( user ): print ( type ( user )) return { \"message\" : str ( user )} ... Send GET request and look at your terminal: flask_authlib.schemas.User is pydantic model which is used for validating & serializing user credentials. You can use pydantic's features in your code. One of these features is dict method. This is not dict object on python, it is one of the useful methods of pydantic.BaseModel . BaseModel.dict Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Let's use it for converting our user credentials to python's dict object: 1 2 3 4 5 6 ... @app . route ( \"/\" ) @auth . jwt_required def home ( user ): return { \"message\" : user . dict ()} ... Yeah \ud83d\ude09 Type Annotations Another feature of pydantic is that you can use your pydantic models as type annotations. It is supported by many IDEs (I use vscode). For instance: We can't see any suggestions. Because we don't know the type of this function argument. For solving this task, we can use type annotations (we can use them everywhere). 1 2 3 4 5 6 # Defining Variable response : ResponseModel = client . post ( ** kwargs ) # Function and class methods' arguments def do_it ( self , data : dict ) -> List [ str ]: # `data` is `dict` object \ud83d\ude42 return list ( self . just_do_it ( data )) Use flask_authlib 's User model for annotating types on your code: Code 1 2 3 4 5 6 7 8 from flask_authlib import JWT , User ... @app . route ( \"/\" ) @auth . jwt_required def home ( user : User ): email = user . email return { \"message\" : user . dict ()} ...","title":"\ud83e\uddd1 Get current user from JWT"},{"location":"jwt-guide/jwt-settings/","text":"JWT modules' customization flask_authlib.JWT allows you to create your own settings object and use it. You should only create a class based on flask_authlib.JwtConfig , make your changes and it's ready for use. Basic app and configuration Create your flask app and import the JwtConfig object from flask_authlib for customization: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import AuthManager from flask_authlib import JwtConfig app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = AuthManager ( app , db ) app . add_url_rule ( rule = \"/\" , view_func = lambda : \"Hello World!\" ) Define your settings class: 1 2 class MySettings ( JwtConfig ): pass Apply your settings: 1 auth = JWT ( app , db , settings = MySettings ) URLs customization 1 2 3 class MySettings ( JwtConfig ): LOGIN_URL : str = \"/api/login\" REGISTER_URL : str = \"api/register\" Changing TABLENAME 1 2 class MySettings ( JwtConfig ): TABLENAME : str = \"accounts\" Minimum password length 1 2 class MySettings ( JwtConfig ): MIN_PASSWORD_LENGTH : int = 12 Custom token lifetime Token Lifetime All jwt tokens have an expiration time. This expiration time is set by the `server-side (in the encoding process). If a token has expired, users can't use it on protected routes. In this library, you can set your token lifetime. 1 2 class MySettings ( JwtConfig ): TOKEN_LIFETIME : int = 60 * 30 # seconds 60x30 = 1800 seconds = 0.5 hour User Info In the Advanced usage of JWT sections, I wrote that you can get user credentials by its JWT token easily. But, there are some cases that we should not do this. For example, if users changed their profile(username, email), the credentials do not match with data on the database. 1 2 class MySettings ( JwtConfig ): USER_INFO_IN_JWT : bool = False Now, we can get only user_id from jwt token (\"sub\") and our jwt_requires decorator(which allows you to get current user) fetch user from the database according to its user_id . If you set this param is False , you can still get user like a previous guide. Alert Messages As you know, if the authentication process raises any exceptions, the server returns 401 response with a status code and error message. For changing this you should create another object for alerts. 1 2 3 4 5 6 7 from flask_authlib import Alerts class MyAlerts ( Alerts ): LOGIN_FAIL : str = \"...\" class MySettings ( JwtConfig ): alerts : Alert = MyAlerts JwtConfig's Defaults 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class JwtConfig : LOGIN_URL : str = \"/login\" REGISTER_URL : str = \"/register\" TABLENAME : str = \"users\" MIN_PASSWORD_LENGTH : int = 8 TOKEN_LIFETIME : int = 60 * 60 # seconds SECRET_KEY : str = secrets . token_hex () USER_INFO_IN_JWT : bool = True alerts : Alerts = Alerts user_schema : User = User","title":"Customization of settings"},{"location":"jwt-guide/jwt-settings/#jwt-modules-customization","text":"flask_authlib.JWT allows you to create your own settings object and use it. You should only create a class based on flask_authlib.JwtConfig , make your changes and it's ready for use.","title":"JWT modules' customization"},{"location":"jwt-guide/jwt-settings/#basic-app-and-configuration","text":"Create your flask app and import the JwtConfig object from flask_authlib for customization: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import AuthManager from flask_authlib import JwtConfig app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = AuthManager ( app , db ) app . add_url_rule ( rule = \"/\" , view_func = lambda : \"Hello World!\" ) Define your settings class: 1 2 class MySettings ( JwtConfig ): pass Apply your settings: 1 auth = JWT ( app , db , settings = MySettings )","title":"Basic app and configuration"},{"location":"jwt-guide/jwt-settings/#urls-customization","text":"1 2 3 class MySettings ( JwtConfig ): LOGIN_URL : str = \"/api/login\" REGISTER_URL : str = \"api/register\"","title":"URLs customization"},{"location":"jwt-guide/jwt-settings/#changing-tablename","text":"1 2 class MySettings ( JwtConfig ): TABLENAME : str = \"accounts\"","title":"Changing TABLENAME"},{"location":"jwt-guide/jwt-settings/#minimum-password-length","text":"1 2 class MySettings ( JwtConfig ): MIN_PASSWORD_LENGTH : int = 12","title":"Minimum password length"},{"location":"jwt-guide/jwt-settings/#custom-token-lifetime","text":"Token Lifetime All jwt tokens have an expiration time. This expiration time is set by the `server-side (in the encoding process). If a token has expired, users can't use it on protected routes. In this library, you can set your token lifetime. 1 2 class MySettings ( JwtConfig ): TOKEN_LIFETIME : int = 60 * 30 # seconds 60x30 = 1800 seconds = 0.5 hour","title":"Custom token lifetime"},{"location":"jwt-guide/jwt-settings/#user-info","text":"In the Advanced usage of JWT sections, I wrote that you can get user credentials by its JWT token easily. But, there are some cases that we should not do this. For example, if users changed their profile(username, email), the credentials do not match with data on the database. 1 2 class MySettings ( JwtConfig ): USER_INFO_IN_JWT : bool = False Now, we can get only user_id from jwt token (\"sub\") and our jwt_requires decorator(which allows you to get current user) fetch user from the database according to its user_id . If you set this param is False , you can still get user like a previous guide.","title":"User Info"},{"location":"jwt-guide/jwt-settings/#alert-messages","text":"As you know, if the authentication process raises any exceptions, the server returns 401 response with a status code and error message. For changing this you should create another object for alerts. 1 2 3 4 5 6 7 from flask_authlib import Alerts class MyAlerts ( Alerts ): LOGIN_FAIL : str = \"...\" class MySettings ( JwtConfig ): alerts : Alert = MyAlerts","title":"Alert Messages"},{"location":"jwt-guide/jwt-settings/#jwtconfigs-defaults","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class JwtConfig : LOGIN_URL : str = \"/login\" REGISTER_URL : str = \"/register\" TABLENAME : str = \"users\" MIN_PASSWORD_LENGTH : int = 8 TOKEN_LIFETIME : int = 60 * 60 # seconds SECRET_KEY : str = secrets . token_hex () USER_INFO_IN_JWT : bool = True alerts : Alerts = Alerts user_schema : User = User","title":"JwtConfig's Defaults"},{"location":"jwt-guide/jwt-usage/","text":"Setup Basic JWT Authentication \ud83e\udde8 Basic application Using JWT authentication on this library is very easy! Just one import & definition! For testing it, create a basic flask application with a database (SQLAlchemy is recommended). We also created one basic route that returns a simple JSON response. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" @app . route ( \"/\" ) def home (): return { \"message\" : \"It should be protected!\" } if __name__ == \"__main__\" : app . run ( debug = True ) # just run this python code and it will be executed Our task is to protect this route by using JWT tokens. For doing this import JWT main class from our flask_authlib : 1 from flask_authlib import JWT Initialize it bypassing your flask app and sqlalchemy db as JWT 's arguments: 1 2 3 from flask_authlib import JWT auth = JWT ( app , db ) Tip If you look at your routes, you will see new API endpoints on your application. They were added by flask_authlib 's JWT submodule. For getting a list of routes, I recommended using the flask's CLI. Yeah, you could do it by python code (using flask. Flask 's url_map ). But, I think it is a very simple & good approach for this task. In this library, pydantic is used for the data part (for validating, serializing). Every field of the user's request the body will be checked & validated! \u2728 Run your development server: 1 $ python server.py or 1 $ flask run Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = JWT ( app , db ) @app . route ( \"/\" ) def home (): return { \"message\" : \"It should be protected!\" } if __name__ == \"__main__\" : app . run ( debug = True ) Testing For testing JWT functionality you can any HTTP clients or python's testing frameworks (unittest, pytest ...). But on this tutorial, I prefer to use postman (useful API development tool). \ud83d\udd10 Registration Basic request: Send empty request body: Checking email validation: Successful registration: 1 2 3 4 5 { email : str # EmailStr on pydantic password : str username : str } \ud83d\udd13 Login Send empty request body: Checking email validation: Successful registration: 1 2 3 4 { password : str username : str } \ud83d\ude80 We have got JWT access token! \ud83e\uddee Decoding You can decode this access_token on jwt.io After the decoding process, you can easily get the user's credentials without querying to your database! CORS I recommend to you use Flask-Cors before making API requests to your flask server from the frontend(angular,vue, react ...). 1 pip install -U flask-cors Basic usage: 1 2 3 4 5 6 7 8 9 from flask import Flask from flask_cors import CORS app = Flask ( __name__ ) CORS ( app ) @app . route ( \"/\" ) def root (): return { \"success\" : True } P.S You can also use CORS on your blueprints Documentation","title":"Setup Basic JWT Authentication"},{"location":"jwt-guide/jwt-usage/#setup-basic-jwt-authentication","text":"","title":"Setup Basic JWT Authentication"},{"location":"jwt-guide/jwt-usage/#basic-application","text":"Using JWT authentication on this library is very easy! Just one import & definition! For testing it, create a basic flask application with a database (SQLAlchemy is recommended). We also created one basic route that returns a simple JSON response. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" @app . route ( \"/\" ) def home (): return { \"message\" : \"It should be protected!\" } if __name__ == \"__main__\" : app . run ( debug = True ) # just run this python code and it will be executed Our task is to protect this route by using JWT tokens. For doing this import JWT main class from our flask_authlib : 1 from flask_authlib import JWT Initialize it bypassing your flask app and sqlalchemy db as JWT 's arguments: 1 2 3 from flask_authlib import JWT auth = JWT ( app , db ) Tip If you look at your routes, you will see new API endpoints on your application. They were added by flask_authlib 's JWT submodule. For getting a list of routes, I recommended using the flask's CLI. Yeah, you could do it by python code (using flask. Flask 's url_map ). But, I think it is a very simple & good approach for this task. In this library, pydantic is used for the data part (for validating, serializing). Every field of the user's request the body will be checked & validated! \u2728 Run your development server: 1 $ python server.py or 1 $ flask run Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask ( __name__ ) db = SQLAlchemy ( app ) app . config [ \"SQLALCHEMY_DATABASE_URI\" ] = \"sqlite:///database.sqlite\" auth = JWT ( app , db ) @app . route ( \"/\" ) def home (): return { \"message\" : \"It should be protected!\" } if __name__ == \"__main__\" : app . run ( debug = True ) Testing For testing JWT functionality you can any HTTP clients or python's testing frameworks (unittest, pytest ...). But on this tutorial, I prefer to use postman (useful API development tool).","title":"\ud83e\udde8 Basic application"},{"location":"jwt-guide/jwt-usage/#registration","text":"Basic request: Send empty request body: Checking email validation: Successful registration: 1 2 3 4 5 { email : str # EmailStr on pydantic password : str username : str }","title":"\ud83d\udd10 Registration"},{"location":"jwt-guide/jwt-usage/#login","text":"Send empty request body: Checking email validation: Successful registration: 1 2 3 4 { password : str username : str } \ud83d\ude80 We have got JWT access token!","title":"\ud83d\udd13 Login"},{"location":"jwt-guide/jwt-usage/#decoding","text":"You can decode this access_token on jwt.io After the decoding process, you can easily get the user's credentials without querying to your database! CORS I recommend to you use Flask-Cors before making API requests to your flask server from the frontend(angular,vue, react ...). 1 pip install -U flask-cors Basic usage: 1 2 3 4 5 6 7 8 9 from flask import Flask from flask_cors import CORS app = Flask ( __name__ ) CORS ( app ) @app . route ( \"/\" ) def root (): return { \"success\" : True } P.S You can also use CORS on your blueprints Documentation","title":"\ud83e\uddee Decoding"},{"location":"user-guide/alerts_config/","text":"flask_authlib.Alerts - a simple configuration that stores alert messages. It is pretty easy that customize alert messages! An alert object from the source code of this library: 1 2 3 4 5 6 7 8 9 10 11 12 class Alerts : EMAIL_ALERT : str = \"This email is already taken!\" USERNAME_ALERT : str = \"This username is already taken!\" REGISTER_SUCCESS : str = \"Registration was successful!\" LOGIN_FAIL : str = \"The username or password is incorrect!\" REGISTER_FAIL : str = \"This email and username is already taken!\" BAD_REQUEST : str = \"Bad request!\" REQUIRED_FIELD : str = \"Please, fill in all required fields!\" Customizing alerts is very same as BaseConfig . Import it, change the values that you want and give your settings object as an argument to Auth again! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import AuthManager from flask_authlib import Alerts app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) class MyAlerts ( Alerts ): pass auth = AuthManager ( app , db , alerts = MyAlerts ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () I want to change the email and username alerts messages: 1 2 3 class MyAlerts ( Alerts ): EMAIL_ALERT = \"if emails.filter(your_email): stop_world()\" USERNAME_ALERT = \"Check your username from our database by SQL injection.\" Or, you can change login_fail 's alert message: 1 2 class MyAlerts ( Alerts ): LOGIN_FAIL = \"Get your password from the database and decode it!\" \ud83c\udf89","title":"Customize Alerts"},{"location":"user-guide/base_config/","text":"flask_authlib.BaseConfig - contains core settings of the library. Default values of this object: 1 2 3 4 5 6 7 8 9 HOME_URL : str = \"/\" LOGIN_URL : str = \"/login\" REGISTER_URL : str = \"/register\" LOGOUT_URL : str = \"/logout\" LOGIN_MESSAGE_CATEGORY = \"info\" MIN_PASSWORD_LENGTH : int = 8 EMAIL_UNIQUE : bool = True HOME_URL - home page URL LOGIN_URL - login page URL REGISTER_URL : register page URL LOGOUT_URL - logout URL LOGIN_MESSAGE_CATEGORY - login message category ( flash message ), it is required by flask_login MIN_PASSWORD_LENGTH - minimum password length, it will be used in registration process. EMAIL_UNIQUE - if it is true , users' email will be validated for uniquennes in the register process. Customizing Base Config Basic Application: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import AuthManager app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) auth = AuthManager ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () Import BaseConfig from flask_authlib and create a python class that will describe your custom settings: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import AuthManager from flask_authlib import BaseConfig app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) class MySettings ( BaseConfig ): pass auth = AuthManager ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () Settings There are also some settings that I do not recommend changing: TEMPLATES_FOLDER_NAME and others that I have not written above. Let's customize settings: 1 2 3 4 5 class MySettings ( BaseConfig ): LOGIN_URL = \"/auth/login\" REGISTER_URL = \"/auth/register\" LOGOUT_URL : str = \"/auth/logout\" MIN_PASSWORD_LENGTH = 12 Now, after customizing we can give our settings object as argument( configs are Optional ) to the Auth class: 1 2 3 4 5 6 7 class MySettings ( BaseConfig ): LOGIN_URL = \"/auth/login\" REGISTER_URL = \"/auth/register\" LOGOUT_URL = \"/auth/logout\" MIN_PASSWORD_LENGTH = 12 auth = AuthManager ( app , db , base_config = MySettings ) Navigate to /login : Yeah, we changed the login URL, then we should navigate /auth/login : Check register URL: Check password length: Check password length validation: Check register functionality: Check logout URL after login: HTTP 302 If we navigate /auth/logout , the built-in logout view clears all sessions and will redirect us to HOME_PAGE .","title":"Customize Base Settings"},{"location":"user-guide/base_config/#customizing-base-config","text":"Basic Application: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import AuthManager app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) auth = AuthManager ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () Import BaseConfig from flask_authlib and create a python class that will describe your custom settings: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import AuthManager from flask_authlib import BaseConfig app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) class MySettings ( BaseConfig ): pass auth = AuthManager ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () Settings There are also some settings that I do not recommend changing: TEMPLATES_FOLDER_NAME and others that I have not written above. Let's customize settings: 1 2 3 4 5 class MySettings ( BaseConfig ): LOGIN_URL = \"/auth/login\" REGISTER_URL = \"/auth/register\" LOGOUT_URL : str = \"/auth/logout\" MIN_PASSWORD_LENGTH = 12 Now, after customizing we can give our settings object as argument( configs are Optional ) to the Auth class: 1 2 3 4 5 6 7 class MySettings ( BaseConfig ): LOGIN_URL = \"/auth/login\" REGISTER_URL = \"/auth/register\" LOGOUT_URL = \"/auth/logout\" MIN_PASSWORD_LENGTH = 12 auth = AuthManager ( app , db , base_config = MySettings ) Navigate to /login : Yeah, we changed the login URL, then we should navigate /auth/login : Check register URL: Check password length: Check password length validation: Check register functionality: Check logout URL after login: HTTP 302 If we navigate /auth/logout , the built-in logout view clears all sessions and will redirect us to HOME_PAGE .","title":"Customizing Base Config"},{"location":"user-guide/basic_usage/","text":"Flask-Authlib uses SQLAlchemy (sqlalchemy extension for flask) for the database part. After installation this ORM, you should import AuthManager and use it like this: 1 2 3 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import AuthManager Define your Flask application , db and AuthManager base object: 1 2 3 4 5 6 7 8 9 10 11 12 13 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_authlib import AuthManager app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) auth = AuthManager ( app , db ) flask_authlib.AuthManager AuthManager takes two arguments(required): app (Flask App) and db (SQLAlchemy). Add a simple route and protect it by flask login's login_required decorator for testing login functionality: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_login import login_required from flask_authlib import AuthManager app = Flask ( __name__ ) app . config . update ( DEBUG = True , SQLALCHEMY_DATABASE_URI = \"sqlite:///database.db\" ) db = SQLAlchemy ( app ) auth = AuthManager ( app , db ) @app . route ( \"/protected\" ) @login_required def protected (): return \"HI, I'M PROTECTED \ud83d\udc4b\" if __name__ == \"__main__\" : app . run () If we try to navigate /protected , it should navigate us to the login page. That is why we used flask_login's @login_required . Next, run your flask application and you will see magic things \ud83d\ude02 (navigate to protected route): Login Page Register Page Tada \ud83c\udf89 If we look our application's directory, we can see new folders which are created by flask_authlib : static/ - stores static files ( js , css , fonts ... ) templates/ - stores *.html files","title":"Basic Usage of Library"},{"location":"user-guide/templates_config/","text":"flask_authlib.TemplateConfig - pages' labels, titles, buttons' colours are stored in this object. TemplateConfig object from source code of this library: 1 2 3 4 5 6 7 8 9 10 11 12 class TemplateConfig : USERNAME_LABEL : str = \"Username\" PASSWORD_LABEL : str = \"Password\" EMAIL_LABEL : str = \"Email address\" LOGIN_TITLE : str = \"Login\" LOGIN_BTN_TEXT : str = \"Login\" LOGIN_PRIMARY_COLOR : str = \"red\" REGISTER_TITLE : str = \"Register\" REGISTER_BTN_TEXT : str = \"Register\" REGISTER_PRIMARY_COLOR : str = \"yellow\" Customizing login and register page's title, login page's primary colour and username label's text content: 1 2 3 4 5 6 7 8 9 10 11 from flask_authlib import TemplateConfig class MyTemplateConfig ( TemplateConfig ): USERNAME_LABEL = \"Your instagram username\" LOGIN_TITLE = \"Welcome!\" REGISTER_TITLE = \"Welcome!\" LOGIN_PRIMARY_COLOR = \"blue\" REGISTER_PRIMARY_COLOR = \"green\" LOGIN_BTN_TEXT : str = \"Send\" REGISTER_BTN_TEXT : str = \"Send\" Login Page: Register Page: Primary colour Primary colour sets the colour of the button and the title. There are List of all primary colors : Blue Violet Green Red Yellow White Black","title":"Customize Templates"}]}